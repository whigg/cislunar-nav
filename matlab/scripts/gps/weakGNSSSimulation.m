% weakGNSSSimulation.m
% Author: Mark Hartigan
% Date  : November 8, 2023
% Description:
%    Simulate weak GNSS measurements at lunar distances

%% reset
clear, close all;
addpath(genpath(pwd));
format long g;          % display long numbers, no scientific notation

%% var init
max_a = 40 * pi/180;    % rad, maximum off-boresight angle link can close

% SPICE kernel initialization
kernels = {'data/naif0012.tls', 'data/de430.bsp', 'data/gm_de431.tpc'};
cspice_furnsh(kernels);

% get Moon, Earth, Sun, and GPS satellite trajectory handles
file = 'data/IAC0MGXFIN_20231150000_01D_05M_ORB.SP3';
[t, moon, earth, sun, sats, satdata] = load_trajectories(file);

a = 6142;               % km, semi-major axis
e = 0.57;               % eccentricity
i = 127*pi/180;         % rad, inclination
RAAN = 0;               % rad, right ascension of the ascending node
w = 90*pi/180;          % rad, argument of perilune
f = 180*pi/180;         % rad, true anomaly
[r, v] = oe2rv(a, e, i, RAAN, w, f, moon.GM);
x0_ = [r; v; 0];        % initial true state vector
P0 = [1 1 1 .001 .001 .001 1]';
% x0 = random('Normal', x0_, P0, [7,1]);    % initial guess
x0 = [  -0.839588747338385
          5804.62075368182
         -7702.26646054383
         0.468536281857995
       0.00012404980000329
       0.00143669662271881
                         0];
P0 = diag(P0.^2);

%% true trajectory
true = importdata('data/GMAT_moonorb.txt');
% change time system to that generated by GMAT (truth data)
% in this case, it's the same interval but a step every 60s
t = (true.data(:,1)' - true.data(1,1)) * 86400 + t(1);         
x_true = true.data(:,2:end)';
n = length(t);          % number of time steps

%% nominal trajectory
opts = odeset('RelTol', 1e-9, 'AbsTol', 1e-12);
F = @(t,x) moondyn(t, x, moon, earth, sun);
[~, x_nom] = ode45(F, t, x0, opts);   % nominal trajectory
x_nom = x_nom';   % keep with convention of cols = time steps

% compute pseudoranges
psr = compute_psr(t, x_true, sats, earth, max_a);

%% Batch filter
phi = @(ti,x) expm(grad(@(y) F(ti, y), x, 7) * (ti - t(1)));    % STM

iter = 10;                      % number of iterations
dX = zeros(size(x0));
W = 1/(0.01^2);                 % relative weight of measurement

for i=1:iter
    HTWH = zeros(7,7);
    HTWy = zeros(7,1);

    for j=1:n
        % find visible satellites and their positions
        visible = psr(:,j) ~= 0;
        pSats = zeros(3, nnz(visible));
        idx = find(visible);    % indices of visible satellites
        for k=1:length(idx)
            pSats(:,k) = sats{idx(k)}(t(j));
        end
        
        X = x_nom(:,j);                 % computed state
        Y = psr(visible,j);             % observed measurement
        y = Y - G(X, pSats);            % measurement residual (O - C)
        H = Ht(X, pSats)*phi(t(j), X);  % measurement matrix

        % compute rank-1 update
        HTWH = HTWH + H'*W*H;
        HTWy = HTWy + H'*W*y;
    end

    dX_hat = (HTWH + inv(P0)) \ (HTWy + P0 \ dX);   % state deviation
    x0 = [x0 x0(:,end) + dX_hat];   % get final estimate
    dX = dX - dX_hat;               % use previous deviation for next iteration
    % P0 = inv(HTWH + inv(P0));       % update covariance
    
    [~, x_nom] = ode45(F, t, x0(:,end), opts);    % nominal trajectory
    x_nom = x_nom';
end

fprintf("Initial offset: %.3f m\n", norm(x0_(1:3) - x0(1:3,end))*1000);
fprintf("Maximum offset: %.3f m\n", maxOffset(x_true(1:3,:)', x_nom(1:3,:)')*1000);

%% plot errors
figure();
err = sqrt(sum((x_true(1:3,:) - x_nom(1:3,:)).^2, 1));
plot(t - t(1), err);
grid on; xlabel("Time (s)"); ylabel("Distance (km)");

figure();
errIter = sqrt(sum((x0(1:3,:) - x0_(1:3)).^2, 1));
plot(0:i, errIter(1:end)*1000);
grid on;
xlabel("Iterations"); ylabel("Initial position error (m)");

%% plot relative orbits
figure();
plot3(x_true(1,:), x_true(2,:), x_true(3,:), 'r--', 'LineWidth', 1);
hold on;
plot3(x_nom(1,:), x_nom(2,:), x_nom(3,:), 'c-.', 'LineWidth', 1);
scatter3(x_true(1,1), x_true(2,1), x_true(3,1), 'ro', 'LineWidth', 1);
scatter3(x0(1,end), x0(2,end), x0(3,end), 'co', 'LineWidth', 1);
% plot3(x0(1,:), x0(2,:), x0(3,:), 'LineWidth', 1);

% moon
[Imoon, ~] = imread("data/lroc_color_poles_1k.jpg");
[xx, yy, zz] = ellipsoid(0, 0, 0, moon.R, moon.R, moon.R);
globe = surf(xx, yy, zz);
set(globe, 'FaceColor', 'texturemap', 'CData', Imoon, 'FaceAlpha', 1, ...
    'EdgeColor', 'none');

hold off; grid on; axis equal;
% set(gcf, 'Color', 'k');
set(gca, 'Color', 'k');
xlabel("x (km)"); ylabel("y (km)"); zlabel("z (km)");
legend(["True Trajectory", "Nominal Trajectory"], 'location', 'best', ...
    'TextColor', 'w');

%% render scene
figure();

plot3(x_true(1,:), x_true(2,:), x_true(3,:), 'c', 'Linewidth', 2); hold on;

x_ef = earth.x(t(end)); x_ef = x_ef(1:3);
x_sf = sun.x(t(end)); x_sf = x_sf(1:3);

% show GPS satellites
for i=1:120
    % GPS trajectories
%     plot3(satdata(i).x(1,:) + x_ef(1), satdata(i).x(2,:) + x_ef(2), ...
%           satdata(i).x(3,:) + x_ef(3), 'r', 'LineWidth', 1);
    % visible GPS sats
    if psr(i,end) ~= 0
        pt = sats{i}(t(end));
        scatter3(pt(1), pt(2), pt(3), 'go', 'Linewidth', 2);
    end
end

% earth

[Iearth, ~] = imread("data/flat_earth_Largest_still.0330.jpg");
[xx, yy, zz] = ellipsoid(x_ef(1), x_ef(2), x_ef(3), earth.R, earth.R, earth.R);
globe = surf(xx, yy, zz);
set(globe, 'FaceColor', 'texturemap', 'CData', flip(Iearth,1), 'FaceAlpha', 1, ...
    'EdgeColor', 'none');

% moon
[xx, yy, zz] = ellipsoid(0, 0, 0, moon.R, moon.R, moon.R);
globe = surf(xx, yy, -zz);
set(globe, 'FaceColor', 'texturemap', 'CData', Imoon, 'FaceAlpha', 1, ...
    'EdgeColor', 'none');

hold off; grid on; axis equal;
% set(gcf, 'Color', 'k');
set(gca, 'Color', 'k');
xlabel("x (km)"); ylabel("y (km)"); zlabel("z (km)");
legend(["Spacecraft Trajectory", "GNSS Satellite"], 'location', 'best', ...
    'TextColor', 'w');

%% plot all GNSS satellites and affiliation
figure();
subset = [];

% show GPS satellites
for i=1:120 
    if i < 38, color = 'r'; name = "BeiDou";            % BeiDou
    elseif i < 64, color = 'b'; name = "Galileo";       % Galileo
    elseif i < 96, color = 'g'; name = "GPS";           % GPS
    elseif i < 99, color = 'm'; name = "QZSS";          % QZSS
    else, color = [.635 0.078 0.184]; name = "GLONASS"; % GLONASS
    end
    % GPS trajectories
    if i == 1 || i == 38 || i == 64 || i == 96 || i == 99
        p = plot3(satdata(i).x(1,:) + x_ef(1), satdata(i).x(2,:) + x_ef(2), ...
              satdata(i).x(3,:) + x_ef(3), 'Color', color, 'LineWidth', ...
              1, 'DisplayName', name);
        subset = [subset p];
    else
        plot3(satdata(i).x(1,:) + x_ef(1), satdata(i).x(2,:) + x_ef(2), ...
              satdata(i).x(3,:) + x_ef(3), 'Color', color, 'LineWidth', 1);
    end
    hold on;
end

% earth
[xx, yy, zz] = ellipsoid(x_ef(1), x_ef(2), x_ef(3), earth.R, earth.R, earth.R);
globe = surf(xx, yy, zz);
set(globe, 'FaceColor', 'texturemap', 'CData', flip(Iearth,1), 'FaceAlpha', 1, ...
    'EdgeColor', 'none');
hold off; axis equal;
xlabel("x (km)"); ylabel("y (km)"); zlabel("z (km)");
legend(subset);

%% cleanup
cspice_unload(kernels);

%% functions

function r = G(x, sats)
%G Measurement model of GPS range. Returns vector of computed ranges.
%   Input:
%    - x; state vector (7,1)
%    - sats; vector of satellite positions + clock offset (n,4)

r = zeros(size(sats,2), 1);

for i=1:length(r), r(i) = sqrt(sum((x(1:3) - sats(:,i)).^2)) + x(7); end
end

function H = Ht(x, sats)
r = G(x, sats);      % range measurements
H = zeros(length(r), length(x));

for i=1:length(r)
    % p = r(i) - x(7);    % transform back to pseudorange
    p = r(i);
    H(i,:) = [(x(1)-sats(1,i))/p (x(2)-sats(2,i))/p (x(3)-sats(3,i))/p 0 0 0 1];
end
end